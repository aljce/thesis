\documentclass[./Thesis.tex]{subfiles}
\begin{document}

\chapter{Termination}
\label{chap:termination}

\epigraph{
  What can be asserted without evidence can also be dismissed without evidence.
}{Christopher Hitchens \cite{hitchens-quote}}

\begin{code}[hide]
  module Termination where
  open import Relation.Nullary.Decidable using (False)
  open import Relation.Nullary.Negation using (contradiction)
  open import Data.Empty using (‚ä•)
  open import AKS.Nat using (‚Ñï; zero; suc; _*_; _<_; _‚â§_; lte; _‚âü_)
  open import AKS.Nat using (+-comm; suc-injective-‚â°)
  open import AKS.Binary using (ùîπ‚Å∫)
  open ùîπ‚Å∫
  open import AKS.Nat.Divisibility using (_div_; Euclidean; Euclidean‚úì)
  open Euclidean using () renaming (q to quotient)
  open import Relation.Binary.PropositionalEquality
    using (_‚â°_; _‚â¢_; module ‚â°-Reasoning)
    renaming (refl to ‚â°-refl; sym to ‚â°-sym; cong to ‚â°-cong; cong‚ÇÇ to ‚â°-cong‚ÇÇ)
  open ‚â°-Reasoning
  open import Data.Unit using (tt)
  open import Polynomial.Simple.AlmostCommutativeRing.Instances using (module Nat)
  open import Polynomial.Simple.Reflection using (solve)
  open Nat.Reflection using (‚àÄ‚ü®_‚ü©)
  open import Data.List using ([]; _‚à∑_)
  open import Function using (_$_)
\end{code}
\section{A Correctness Interlude}
\label{sec:a-correctness-interlude}
The previous chapter omitted a critical flaw in it's analysis. The code below is
rejected by the \Agda{} compiler. The compiler's \textit{termination checker} \cite{agda}
fails as \Agda{} can not infer that the result of non zero integer division by
two always returns an integer strictly smaller than the input. The termination
checker ensures than every function is total or in other
words the termination checker disallows infinite loops. This termination proof
is obvious but termination proofs can quickly become complex. Famously checking
termination, commonly called the halting problem is undecidable. 
\begin{code}[hide]
  module Bad‚ÇÅ where
    {-# TERMINATING #-}
\end{code}
\begin{code}
    ‚ü¶_‚áë‚üß‚Å∫ : ‚àÄ (n : ‚Ñï) {‚â¢0 : False (n ‚âü 0)} ‚Üí ùîπ‚Å∫
    ‚ü¶ suc n ‚áë‚üß‚Å∫ with suc n div 2
    ... | Euclidean‚úì (suc q) 0 _ _ = ‚ü¶ suc q ‚áë‚üß‚Å∫ 0·µá
    ... | Euclidean‚úì zero    1 _ _ = ùïì1·µá
    ... | Euclidean‚úì (suc q) 1 _ _ = ‚ü¶ suc q ‚áë‚üß‚Å∫ 1·µá
\end{code}
This checker is a keystone of the correctness of the logic of \Agda{}. Consider
the following function with a similar call graph. Instead of the input
decreasing to some base case it doubles every recursive call. This function can
be used to prove falsehood, thus a logic with unconstrained recursion is
inconsistent.
\begin{code}[hide]
  module Bad‚ÇÇ where
    {-# TERMINATING #-}
\end{code}
\begin{code}
    increasing : ‚Ñï ‚Üí ‚ä•
    increasing n with 2 * n
    ... | q = increasing q

    false : ‚ä•
    false = increasing 0
\end{code}
In fact the example above can be simplified in the following code. In English
this code expresses the famous fallacy of circular reasoning ``false is true
because false is true''.
\begin{code}[hide]
  module Bad‚ÇÉ where
    {-# TERMINATING #-}
\end{code}
\begin{code}
    false : ‚ä•
    false = false
\end{code}
Thankfully none of these false expressions are accepted by the \Agda{} compiler.
This begs the question how does \Agda{} determine which recursive functions to
accept. How can it solve the halting problem? The answer is unsurprisingly it
does not solve the halting problem. Instead the compiler only accepts recursive
calls that are \textit{structurally decreasing}, a small
subset of the set of recursive functions. A recursive call is structurally
decreasing if the call occurs on a strict sub expression \cite{agda}. The
expression $\AgdaInductiveConstructor{suc} \, n$ is a strict sub expression of
$\AgdaInductiveConstructor{suc} \,
  (\AgdaInductiveConstructor{suc} \,
    (\AgdaInductiveConstructor{suc} \, n))
$
but $\AgdaInductiveConstructor{suc} \, n$ is not a strict sub expression of
$\AgdaInductiveConstructor{suc} \, n$.
Addition, our first example of recursion, is acceptable as
$n <_{sub} \AgdaInductiveConstructor{suc} \, n$.
\begin{code}[hide]
  module Add where
\end{code}
\begin{code}
    _+_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
    zero + m = m
    (suc n) + m = suc (n + m)
\end{code}
\begin{code}[hide]
  open import AKS.Nat using (_+_)
\end{code}
The following inductive definition of Fibonacci
has structurally decreasing calls as
$\AgdaInductiveConstructor{suc} \, n <_{sub} \AgdaInductiveConstructor{suc} \, (\AgdaInductiveConstructor{suc} \, n)$
and
$n <_{sub} \AgdaInductiveConstructor{suc} \, (\AgdaInductiveConstructor{suc} \, n)$.
\begin{code}
  fib : ‚Ñï ‚Üí ‚Ñï
  fib zero = 0
  fib (suc zero) = 1
  fib (suc (suc n)) = fib (suc n) + fib n
\end{code}
So far all the recursive functions described have been
\textit{primitive recursive} \cite{soare}. This is a large class but the set of
structurally decreasing functions is larger than the set of primitive
recursive functions. The Ackerrmann function is the conical example of a non
primitive recursive function. \begin{code}
  ack : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
  ack zero m = suc m
  ack (suc n) zero = ack n (suc zero)
  ack (suc n) (suc m) = ack n (ack (suc n) m)
\end{code}
\Agda{} accepts this definition as the recursive
calls are decreasing lexicographically.
The recursive call in the second case decreases in the first argument so
the second argument increasing is acceptable
$
(n, \, \AgdaInductiveConstructor{suc} \, \AgdaInductiveConstructor{zero})
<_{sub}
(\AgdaInductiveConstructor{suc} \, n, \, \AgdaInductiveConstructor{zero})
$.
For a similar reason the outer call in the third case is acceptable
$
(n, \, \AgdaFunction{ack} \, (\AgdaInductiveConstructor{suc} \, n) \, m)
<_{sub}
(\AgdaInductiveConstructor{suc} \, n, \, \AgdaInductiveConstructor{suc} \, m)
$.
The inner call is acceptable as the second argument decreases while the first
stays constant, this is lexicographic order
$
(\AgdaInductiveConstructor{suc} \, n, \, m)
<_{sub}
(\AgdaInductiveConstructor{suc} \, n, \, \AgdaInductiveConstructor{suc} \, m)
$. \\

An astute reader may have noticed a pattern. \Agda{} accepts your recursive
definition if it can infer a structural \textit{well founded relation}
\cite{soare}.
\begin{align}
  \label{eqn:wellfounded-linear}
  0 < 1 < 2 < 3 < 4 < 5
\end{align}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \Tree
    [.3
      {$0 < 3$}
      [.{$1 < 3$}
        {$0 < 1$}
      ]
      [.{$2 < 3$}
        {$0 < 2$}
        [.{$1 < 2$}
          {$0 < 1$}
        ]
      ]
    ]
  \end{tikzpicture}
  \caption{A well founded tree }
  \label{fig:wellfounded-tree}
\end{figure}

\begin{code}
  data Acc {A : Set} (_<_ : A ‚Üí A ‚Üí Set) (bound : A) : Set where
    acc : (‚àÄ {lower} ‚Üí lower < bound ‚Üí Acc _<_ lower)
        ‚Üí Acc _<_ bound

  subrelation
      : ‚àÄ {A : Set} {_<‚ÇÅ_ : A ‚Üí A ‚Üí Set} {_<‚ÇÇ_ : A ‚Üí A ‚Üí Set} {n}
      ‚Üí (‚àÄ {a b} ‚Üí a <‚ÇÇ b ‚Üí a <‚ÇÅ b)
      ‚Üí Acc _<‚ÇÅ_ n
      ‚Üí Acc _<‚ÇÇ_ n
  subrelation <‚ÇÇ‚áí<‚ÇÅ (acc down) =
    acc Œª x<‚ÇÇn ‚Üí subrelation <‚ÇÇ‚áí<‚ÇÅ (down (<‚ÇÇ‚áí<‚ÇÅ x<‚ÇÇn))

  data _‚â§‚Å±_ (n : ‚Ñï) (m : ‚Ñï) : Set where
    ‚â§-same : n ‚â° m ‚Üí n ‚â§‚Å± m
    ‚â§-step : ‚àÄ {o} ‚Üí suc o ‚â° m ‚Üí n ‚â§‚Å± o ‚Üí n ‚â§‚Å± m

  _<‚Å±_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Set
  n <‚Å± m = suc n ‚â§‚Å± m

  <‚Å±-well-founded : ‚àÄ {n} ‚Üí Acc _<‚Å±_ n
  <‚Å±-count-down : ‚àÄ {m n} ‚Üí m <‚Å± n ‚Üí Acc _<‚Å±_ m

  <‚Å±-well-founded {n} = acc (Œª x<‚Å±n ‚Üí <‚Å±-count-down x<‚Å±n)
  <‚Å±-count-down {m} {suc .m} (‚â§-same ‚â°-refl) = <‚Å±-well-founded {m}
  <‚Å±-count-down {m} {suc n} (‚â§-step ‚â°-refl m‚â§n) = <‚Å±-count-down {m} {n} m‚â§n

  ‚â§‚áí‚â§‚Å± : ‚àÄ {a b} ‚Üí a ‚â§ b ‚Üí a ‚â§‚Å± b
  ‚â§‚áí‚â§‚Å± {a} {b} (lte k a+k‚â°b) = loop a b k $ begin
    k + a ‚â°‚ü® +-comm k a ‚ü© a + k ‚â°‚ü® a+k‚â°b ‚ü© b ‚àé
    where
    loop : ‚àÄ a b k ‚Üí k + a ‚â° b ‚Üí a ‚â§‚Å± b
    loop a b zero 0+a‚â°b = ‚â§-same $ begin
      a ‚â°‚ü®‚ü© 0 + a ‚â°‚ü® 0+a‚â°b ‚ü© b ‚àé
    loop a (suc b) (suc k) 1+k+a‚â°1+b = ‚â§-step ‚â°-refl $ loop a b k $ begin
      k + a ‚â°‚ü® suc-injective-‚â° 1+k+a‚â°1+b ‚ü© b ‚àé

  <‚áí<‚Å± : ‚àÄ {a b} ‚Üí a < b ‚Üí a <‚Å± b
  <‚áí<‚Å± {a} {b} a<b = ‚â§‚áí‚â§‚Å± {suc a} {b} a<b

  <-well-founded : ‚àÄ {n} ‚Üí Acc _<_ n
  <-well-founded {n} = subrelation <‚áí<‚Å± <‚Å±-well-founded
\end{code}

\begin{code}
  div-< : ‚àÄ n q r {q‚â¢0 : False (q ‚âü 0)} ‚Üí n ‚â° r + 2 * q ‚Üí q < n
\end{code}
\begin{code}[hide]
  div-< n (suc q) r ‚â°-refl = lte (q + r) (‚àÄ‚ü® q ‚à∑ r ‚à∑ [] ‚ü©)
\end{code}
\begin{code}
  ‚ü¶_,_‚áë‚üß ∞ : ‚àÄ (n : ‚Ñï) (acc : Acc _<_ n) {‚â¢0 : False (n ‚âü 0)} ‚Üí ùîπ‚Å∫
  ‚ü¶ suc n , acc down ‚áë‚üß ∞ with suc n div 2
  ... | Euclidean‚úì (suc q) 0 pf _ = ‚ü¶ suc q , down (div-< (suc n) (suc q) 0 pf) ‚áë‚üß ∞ 0·µá
  ... | Euclidean‚úì zero    1 _ _ = ùïì1·µá
  ... | Euclidean‚úì (suc q) 1 pf _ = ‚ü¶ suc q , down (div-< (suc n) (suc q) 1 pf) ‚áë‚üß ∞ 1·µá

  ‚ü¶_‚áë‚üß‚Å∫ : ‚àÄ (n : ‚Ñï) {‚â¢0 : False (n ‚âü 0)} ‚Üí ùîπ‚Å∫
  ‚ü¶ suc n ‚áë‚üß‚Å∫ = ‚ü¶ suc n , <-well-founded ‚áë‚üß ∞
\end{code}

\end{document}
